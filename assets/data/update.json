{
  "ops": [
    {
      "op": "write",
      "path": "scripts/gen-file-inventory.mjs",
      "content": "// scripts/gen-file-inventory.mjs\n// Dependency-free, env-aware inventory generator with robust logging\n\nimport { execFile } from 'node:child_process';\nimport { promisify } from 'node:util';\nimport { promises as fs } from 'node:fs';\nimport path from 'node:path';\n\nconst execFileAsync = promisify(execFile);\n\nconst OUT_JSON    = process.env.INVENTORY_OUT_JSON    || 'dev/data/file-tree.json';\nconst OUT_TXT     = process.env.INVENTORY_OUT_TXT     || 'dev/data/file-tree.txt';\nconst OUT_METRICS = process.env.INVENTORY_METRICS     || 'dev/data/repo-metrics.json';\nconst RUN_LOG     = process.env.INVENTORY_RUN_LOG     || 'dev/data/run-log.txt';\nconst IGNORE_RAW  = process.env.INVENTORY_IGNORE      || 'archive/**,dev/**/archive/**,.git/**,node_modules/**,.github/**';\nconst IGNORE = IGNORE_RAW.split(',').map(s => s.trim()).filter(Boolean);\n\nfunction toKB(bytes){ return Math.round(bytes / 1024); }\nfunction nowISO(){ return new Date().toISOString(); }\nasync function ensureDirFor(filePath){ await fs.mkdir(path.dirname(filePath), { recursive: true }); }\nasync function statSafe(p){ try { return await fs.stat(p); } catch { return null; } }\n\nasync function appendRunLog(lines){\n  await ensureDirFor(RUN_LOG);\n  await fs.appendFile(RUN_LOG, lines.join('\\n') + '\\n');\n}\n\nasync function writeDefaults(){\n  await ensureDirFor(OUT_JSON);\n  await ensureDirFor(OUT_TXT);\n  await ensureDirFor(OUT_METRICS);\n  await fs.writeFile(OUT_JSON, '[]\\n');\n  await fs.writeFile(OUT_TXT, '');\n  await fs.writeFile(OUT_METRICS, JSON.stringify({ generated_at: nowISO(), duration_ms: 0, files_tracked: 0, total_bytes: 0, total_kb: 0 }, null, 2) + '\\n');\n}\n\nasync function gitTrackedFilesWithExcludes(){\n  try {\n    const excludeArgs = [];\n    for (const patt of IGNORE) excludeArgs.push(`:(exclude)${patt}`);\n    const args = ['ls-files', '-z', '--', ...excludeArgs];\n    const { stdout } = await execFileAsync('git', args, { maxBuffer: 1024 * 1024 * 64 });\n    return stdout.split('\\u0000').filter(Boolean);\n  } catch (err) {\n    console.error('[inventory] git ls-files failed, continuing with empty set:', err?.message || err);\n    return [];\n  }\n}\n\nasync function postStepSummary(metrics, items){\n  try {\n    const summaryPath = process.env.GITHUB_STEP_SUMMARY;\n    if (!summaryPath) return;\n    const lines = [\n      `# Repo Inventory`,\n      '',\n      `**Generated:** ${metrics.generated_at}`,\n      '',\n      '| metric | value |',\n      '|---|---:|',\n      `| files_tracked | ${metrics.files_tracked} |`,\n      `| total_kb | ${metrics.total_kb} |`,\n      `| duration_ms | ${metrics.duration_ms} |`,\n      '',\n      items.length ? '### First 10 files' : '(_no files tracked_)',\n    ];\n    if (items.length){\n      for (const i of items.slice(0,10)) lines.push(`- \\`${i.path}\\` (${i.size_kb} KB)`);\n    }\n    await fs.appendFile(summaryPath, lines.join('\\n') + '\\n');\n  } catch (e) {\n    console.warn('[inventory] failed to write step summary:', e?.message || e);\n  }\n}\n\nasync function main(){\n  const started = Date.now();\n\n  // Config log\n  const cfg = [\n    `[inventory] start @ ${nowISO()}`,\n    `[inventory] OUT_JSON    = ${OUT_JSON}`,\n    `[inventory] OUT_TXT     = ${OUT_TXT}`,\n    `[inventory] OUT_METRICS = ${OUT_METRICS}`,\n    `[inventory] RUN_LOG     = ${RUN_LOG}`,\n    `[inventory] IGNORE      = ${IGNORE.join(', ') || '(none)'}`,\n  ];\n  console.log(cfg.join('\\n'));\n  await appendRunLog(cfg);\n\n  // Always create valid outputs first\n  await writeDefaults();\n\n  // Collect files\n  const files = await gitTrackedFilesWithExcludes();\n  let totalBytes = 0;\n  const items = [];\n  for (const f of files){\n    const st = await statSafe(f);\n    if (!st || !st.isFile()) continue;\n    totalBytes += st.size;\n    items.push({ path: f, size: st.size, size_kb: toKB(st.size) });\n  }\n\n  items.sort((a,b)=> a.path.localeCompare(b.path));\n  const txt = items.map(i=> i.path).join('\\n') + (items.length ? '\\n' : '');\n\n  const metrics = {\n    generated_at: nowISO(),\n    duration_ms: Date.now() - started,\n    files_tracked: items.length,\n    total_bytes: totalBytes,\n    total_kb: toKB(totalBytes)\n  };\n\n  await fs.writeFile(OUT_JSON, JSON.stringify(items, null, 2) + '\\n');\n  await fs.writeFile(OUT_TXT, txt);\n  await fs.writeFile(OUT_METRICS, JSON.stringify(metrics, null, 2) + '\\n');\n\n  // Console + run log\n  const head = items.slice(0, 10).map(i => `- ${i.path} (${i.size_kb} KB)`);\n  const foot = items.length > 10 ? [`â€¦ +${items.length - 10} more`] : [];\n  const logLines = [\n    `[inventory] wrote ${items.length} entries`,\n    `[inventory] total_kb=${metrics.total_kb} duration_ms=${metrics.duration_ms}`,\n    ...head,\n    ...foot,\n    '[inventory] done.'\n  ];\n  console.log(logLines.join('\\n'));\n  await appendRunLog(logLines.map(s => `[${nowISO()}] ${s}`));\n\n  // Actions Job Summary\n  await postStepSummary(metrics, items);\n}\n\nmain().catch(err => {\n  const msg = `[inventory] failed: ${err?.stack || err}`;\n  console.error(msg);\n  appendRunLog([`[${nowISO()}] ${msg}`]).finally(()=>{ process.exitCode = 1; });\n});\n"
    }
  ]
}
