{
  "ops": [
    {
      "op": "write",
      "path": "scripts/gen-file-inventory.mjs",
      "content": "// scripts/gen-file-inventory.mjs\\n// Env-aware, dependency-free file inventory generator\\n// Writes: dev/data/file-tree.json, dev/data/file-tree.txt, dev/data/repo-metrics.json\\n\\nimport { execFile } from 'node:child_process';\\nimport { promisify } from 'node:util';\\nimport { promises as fs } from 'node:fs';\\nimport path from 'node:path';\\n\\nconst execFileAsync = promisify(execFile);\\n\\n// Allow override via env; otherwise use sensible defaults\\nconst OUT_JSON    = process.env.INVENTORY_OUT_JSON    || 'dev/data/file-tree.json';\\nconst OUT_TXT     = process.env.INVENTORY_OUT_TXT     || 'dev/data/file-tree.txt';\\nconst OUT_METRICS = process.env.INVENTORY_METRICS     || 'dev/data/repo-metrics.json';\\nconst IGNORE_RAW  = process.env.INVENTORY_IGNORE      || 'archive/**,dev/**/archive/**,.git/**,node_modules/**,.github/**';\\nconst IGNORE = IGNORE_RAW.split(',').map(s => s.trim()).filter(Boolean);\\n\\nfunction toKB(bytes){ return Math.round(bytes / 1024); }\\n\\nasync function gitTrackedFilesWithExcludes(){\\n  // Build Git pathspec excludes as ':(exclude)<pattern>' entries\\n  const excludeArgs = [];\\n  for (const patt of IGNORE) excludeArgs.push(`:(exclude)${patt}`);\\n  // -z for NUL delim to avoid path issues\\n  const args = ['ls-files', '-z', '--', ...excludeArgs];\\n  const { stdout } = await execFileAsync('git', args, { maxBuffer: 1024 * 1024 * 64 });\\n  const files = stdout.split('\\0').filter(Boolean);\\n  return files;\\n}\\n\\nasync function statSafe(p){ try { return await fs.stat(p); } catch { return null; } }\\n\\nasync function ensureDirFor(filePath){\\n  await fs.mkdir(path.dirname(filePath), { recursive: true });\\n}\\n\\nasync function main(){\\n  const started = Date.now();\\n  const files = await gitTrackedFilesWithExcludes();\\n\\n  let totalBytes = 0;\\n  const items = [];\\n  for (const f of files){\\n    const st = await statSafe(f);\\n    if (!st || !st.isFile()) continue;\\n    totalBytes += st.size;\\n    items.push({ path: f, size: st.size, size_kb: toKB(st.size) });\\n  }\\n\\n  // Sort for determinism\\n  items.sort((a,b)=> a.path.localeCompare(b.path));\\n\\n  // Text listing (one path per line)\\n  const txt = items.map(i=> i.path).join('\\n') + (items.length ? '\\n' : '');\\n\\n  // Metrics\\n  const metrics = {\\n    generated_at: new Date().toISOString(),\\n    duration_ms: Date.now() - started,\\n    files_tracked: items.length,\\n    total_bytes: totalBytes,\\n    total_kb: toKB(totalBytes)\\n  };\\n\\n  await ensureDirFor(OUT_JSON);\\n  await ensureDirFor(OUT_TXT);\\n  await ensureDirFor(OUT_METRICS);\\n\\n  await fs.writeFile(OUT_JSON, JSON.stringify(items, null, 2) + '\\n');\\n  await fs.writeFile(OUT_TXT, txt);\\n  await fs.writeFile(OUT_METRICS, JSON.stringify(metrics, null, 2) + '\\n');\\n\\n  console.log(`[inventory] files: ${items.length}, total_kb: ${metrics.total_kb}`);\\n}\\n\\nmain().catch(err => {\\n  console.error('[inventory] failed:', err);\\n  process.exitCode = 1;\\n});\\n"
    },
    {
      "op": "write",
      "path": "scripts/repo-snapshot.mjs",
      "content": "// scripts/repo-snapshot.mjs\\n// Creates a time-stamped repo snapshot from dev/data/file-tree.json into dev/archive/snapshot_<epoch>.json\\n\\nimport { execFile } from 'node:child_process';\\nimport { promisify } from 'node:util';\\nimport { promises as fs } from 'node:fs';\\nimport path from 'node:path';\\n\\nconst execFileAsync = promisify(execFile);\\n\\nconst IN_JSON  = process.env.SNAPSHOT_SRC || 'dev/data/file-tree.json';\\nconst OUT_DIR  = process.env.SNAPSHOT_DIR || 'dev/archive';\\n\\nasync function ensureDir(p){ await fs.mkdir(p, { recursive: true }); }\\n\\nasync function gitCommit(){\\n  try {\\n    const { stdout } = await execFileAsync('git', ['rev-parse', '--short', 'HEAD']);\\n    return stdout.trim();\\n  } catch { return null; }\\n}\\n\\nasync function main(){\\n  const epoch = Math.floor(Date.now() / 1000);\\n  const commit = await gitCommit();\\n  const raw = await fs.readFile(IN_JSON, 'utf8');\\n  const items = JSON.parse(raw);\\n  const snapshot = { generated_at: new Date().toISOString(), epoch, commit, count: items.length, items };\\n  await ensureDir(OUT_DIR);\\n  const outPath = path.join(OUT_DIR, `snapshot_${epoch}.json`);\\n  await fs.writeFile(outPath, JSON.stringify(snapshot, null, 2) + '\\n');\\n  console.log('[snapshot] wrote', outPath, 'items:', items.length);\\n}\\n\\nmain().catch(err => {\\n  console.error('[snapshot] failed:', err);\\n  process.exitCode = 1;\\n});\\n"
    }
  ]
}
