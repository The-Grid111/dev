{
  "branch": "main",
  "ops": [
    {
      "op": "write",
      "path": "scripts/gen-file-inventory.mjs",
      "content": "// scripts/gen-file-inventory.mjs\\n// Env-aware, dependency-free file inventory generator\\n// Reads outputs/ignores from env and lists tracked files using Git.\\n\\nimport { execFile } from 'node:child_process';\\nimport { promisify } from 'node:util';\\nimport { promises as fs } from 'node:fs';\\nimport path from 'node:path';\\n\\nconst execFileAsync = promisify(execFile);\\n\\nconst OUT_JSON    = process.env.INVENTORY_OUT_JSON   || 'dev/data/file-tree.json';\\nconst OUT_TXT     = process.env.INVENTORY_OUT_TXT    || 'dev/data/file-tree.txt';\\nconst OUT_METRICS = process.env.INVENTORY_METRICS    || 'dev/data/repo-metrics.json';\\nconst IGNORE_RAW  = process.env.INVENTORY_IGNORE     || 'archive/**,dev/**/archive/**,.git/**,node_modules/**,.github/**';\\n\\nconst IGNORE = IGNORE_RAW\\n  .split(',')\\n  .map(s => s.trim())\\n  .filter(Boolean);\\n\\nfunction toKB(bytes) { return Math.round(bytes / 1024); }\\n\\nasync function gitTrackedFilesWithExcludes() {\\n  // Build Git pathspec excludes: :(exclude)pattern\\n  const excludeArgs = [];\\n  for (const patt of IGNORE) excludeArgs.push(`:(exclude)${patt}`);\\n  // -z for NUL delim to avoid path issues\\n  const args = ['ls-files', '-z', '--', ...excludeArgs];\\n  const { stdout } = await execFileAsync('git', args, { maxBuffer: 1024 * 1024 * 64 });\\n  const files = stdout.split('\\0').filter(Boolean);\\n  return files;\\n}\\n\\nasync function statSafe(p) {\\n  try { return await fs.stat(p); } catch { return null; }\\n}\\n\\nfunction treeify(paths) {\\n  // Produce a directory tree object and a simple text tree.\\n  const root = {};\\n  for (const p of paths) {\\n    const parts = p.split('/');\\n    let cur = root;\\n    for (let i = 0; i < parts.length; i++) {\\n      const part = parts[i];\\n      if (!cur[part]) cur[part] = (i === parts.length - 1) ? null : {};\\n      else if (cur[part] === null && i < parts.length - 1) cur[part] = {};\\n      cur = cur[part] ?? {};\\n    }\\n  }\\n  const lines = [];\\n  function walk(node, prefix = '') {\\n    const keys = Object.keys(node).sort();\\n    keys.forEach((k, idx) => {\\n      const last = idx === keys.length - 1;\\n      const elbow = last ? '└── ' : '├── ';\\n      lines.push(prefix + elbow + k);\\n      const child = node[k];\\n      if (child && typeof child === 'object') {\\n        walk(child, prefix + (last ? '    ' : '│   '));\\n      }\\n    });\\n  }\\n  walk(root, '');\\n  return lines.join('\\n');\\n}\\n\\nasync function ensureDirFor(filePath) {\\n  await fs.mkdir(path.dirname(filePath), { recursive: true });\\n}\\n\\nasync function main() {\\n  const started = Date.now();\\n  const files = await gitTrackedFilesWithExcludes();\\n\\n  // Enrich with size and type\\n  let totalBytes = 0;\\n  const items = [];\\n  for (const f of files) {\\n    const st = await statSafe(f);\\n    if (!st || !st.isFile()) continue;\\n    totalBytes += st.size;\\n    items.push({ path: f, size: st.size, size_kb: toKB(st.size) });\\n  }\\n\\n  // Simple metrics\\n  const metrics = {\\n    generated_at: new Date().toISOString(),\\n    duration_ms: Date.now() - started,\\n    files_tracked: items.length,\\n    total_bytes: totalBytes,\\n    total_kb: toKB(totalBytes),\\n    ignore_patterns: IGNORE\\n  };\\n\\n  // Output JSON list and metrics\\n  await ensureDirFor(OUT_JSON);\\n  await ensureDirFor(OUT_METRICS);\\n  await fs.writeFile(OUT_JSON, JSON.stringify({ files: items }, null, 2) + '\\n');\\n  await fs.writeFile(OUT_METRICS, JSON.stringify(metrics, null, 2) + '\\n');\\n\\n  // Output a readable text tree\\n  const treeText = treeify(items.map(i => i.path)) + '\\n';\\n  await ensureDirFor(OUT_TXT);\\n  await fs.writeFile(OUT_TXT, treeText);\\n\\n  console.log('Inventory written:', { OUT_JSON, OUT_TXT, OUT_METRICS });\\n}\\n\\nmain().catch(err => {\\n  console.error('gen-file-inventory failed:', err);\\n  process.exitCode = 1;\\n});\\n"
    }
  ]
}
